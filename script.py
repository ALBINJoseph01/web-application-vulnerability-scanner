import requests
import concurrent.futures
import click
import json
from urllib.parse import urljoin
from bs4 import BeautifulSoup

class WebScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.session = requests.Session()

    def scan_url(self, url, payloads, method='GET', text_box_names=None):
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "'<img src=x onerror=alert(1)>",
            "<svg/onload=alert(1)>",
            "<iframe src=javascript:alert(1)>",
            "<body onload=alert(1)>",
            "<a href='javascript:alert(1)'>Click me</a>",
        ]
        if text_box_names is None:
            text_box_names = []
        
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self.check_xss, url, xss_payloads, method),
                executor.submit(self.check_xss_in_text_box, url, xss_payloads, method, text_box_names),
                executor.submit(self.check_sqli, url, payloads.get('sqli', "' OR '1'='1"), method),
                executor.submit(self.check_cookies, url, method),
                executor.submit(self.check_csrf, url, method),
                executor.submit(self.check_open_redirect, url, method),
                executor.submit(self.check_insecure_headers, url, method),
            ]
            for future in concurrent.futures.as_completed(futures):
                try:
                    future.result()
                except Exception as exc:
                    click.echo(f"Error in scanning: {exc}")

    def check_xss(self, url, payloads, method='GET'):
        for payload in payloads:
            try:
                response = self.make_request(url, payload, method)
                if payload in response.text:
                    self.vulnerabilities.append(f"Possible XSS vulnerability found at {url} with payload: {payload}")
            except requests.RequestException as e:
                click.echo(f"Failed to perform XSS check on {url}: {e}")

    def check_xss_in_text_box(self, url, payloads, method='GET', text_box_names=None):
        try:
            response = self.session.request(method, url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:
                action = form.get('action')
                if not action.startswith(('http://', 'https://')):
                    action = urljoin(url, action)
                
                form_data = {}
                for input_tag in form.find_all('input'):
                    name = input_tag.get('name')
                    if name in text_box_names:
                        form_data[name] = payloads[0] 

                form_data = {}
                for input_tag in form.find_all(['input', 'textarea']):
                    name = input_tag.get('name')
                    if name in text_box_names:
                        for payload in payloads:
                            form_data[name] = payload
                            if method == 'POST':
                                response = self.session.post(action, data=form_data)
                            else:
                                response = self.session.get(action, params=form_data)

                            if self.detect_xss_in_response(response.text, payload):
                                self.vulnerabilities.append(f"Possible XSS vulnerability found in text box '{name}' at {url} with payload: {payload}")

        except requests.RequestException as e:
            click.echo(f"Failed to perform XSS check on text boxes at {url}: {e}")

    def detect_xss_in_response(self, response_text, payload):
        if payload in response_text:
            return True

        dangerous_patterns = [
            '"><script>', '<svg', '<img src', '<iframe', 'onerror=', 'onload=',
            '<object', '<embed', 'document.cookie', 'document.domain', 'document.write', 
            'window.location', 'javascript:', 'eval('
        ]
        for pattern in dangerous_patterns:
            if pattern in response_text:
                return True
        
        return False

    def check_sqli(self, url, payload, method='GET'):
        try:
            response = self.make_request(url, payload, method)
            if "error" in response.text or "syntax" in response.text:
                self.vulnerabilities.append("Possible SQL Injection vulnerability found.")
        except requests.RequestException as e:
            click.echo(f"Failed to perform SQLi check on {url}: {e}")

    def check_cookies(self, url, method='GET'):
        try:
            response = self.session.request(method, url)
            if 'Set-Cookie' in response.headers:
                cookies = response.headers['Set-Cookie']
                if 'Secure' not in cookies or 'HttpOnly' not in cookies:
                    self.vulnerabilities.append("Cookies without Secure or HttpOnly flags.")
        except requests.RequestException as e:
            click.echo(f"Failed to perform cookie check on {url}: {e}")

    def check_csrf(self, url, method='GET'):
        try:
            response = self.session.request(method, url)
            if 'csrf' not in response.text:
                self.vulnerabilities.append("Possible CSRF vulnerability found.")
        except requests.RequestException as e:
            click.echo(f"Failed to perform CSRF check on {url}: {e}")

    def check_open_redirect(self, url, method='GET'):
        payload = "https://evil.com"
        try:
            response = self.make_request(url, payload, method)
            if response.status_code == 302 and response.headers.get('Location') == payload:
                self.vulnerabilities.append("Possible Open Redirect vulnerability found.")
        except requests.RequestException as e:
            click.echo(f"Failed to perform Open Redirect check on {url}: {e}")

    def check_insecure_headers(self, url, method='GET'):
        try:
            response = self.session.request(method, url)
            insecure_headers = ['X-Frame-Options', 'X-XSS-Protection', 'X-Content-Type-Options']
            for header in insecure_headers:
                if header not in response.headers:
                    self.vulnerabilities.append(f"Missing secure header: {header}")
        except requests.RequestException as e:
            click.echo(f"Failed to perform insecure headers check on {url}: {e}")

    def make_request(self, url, payload, method):
        if method == 'GET':
            return self.session.get(url, params={'q': payload})
        elif method == 'POST':
            return self.session.post(url, data={'q': payload})

    def report(self, output_format='text'):
        if not self.vulnerabilities:
            click.echo("No vulnerabilities found.")
        else:
            if output_format == 'text':
                click.echo("Vulnerabilities found:")
                for vuln in self.vulnerabilities:
                    click.echo(f" - {vuln}")
            elif output_format == 'json':
                click.echo(json.dumps(self.vulnerabilities, indent=4))

def load_payloads(file_path):
    payloads = {}
    try:
        with open(file_path, 'r') as file:
            for line in file:
                key, value = line.strip().split(':', 1)
                payloads[key] = value.strip().split(',')
    except Exception as e:
        click.echo(f"Failed to load payloads from {file_path}: {e}")
    return payloads

@click.group()
def cli():
    pass

@cli.command()
@click.argument('url')
@click.option('--payload_file', default=None, help='Path to the payloads .txt file')
@click.option('--output_format', default='text', help='Format of the output report (text or json)')
@click.option('--method', default='GET', type=click.Choice(['GET', 'POST']), help='HTTP method to use for scanning (GET or POST)')
@click.option('--text_box_names', default=None, help='Comma-separated list of text box names to test for XSS')
def scan(url, payload_file, output_format, method, text_box_names):
    payloads = {}
    if payload_file:
        payloads = load_payloads(payload_file)
    
    if text_box_names:
        text_box_names = [name.strip() for name in text_box_names.split(',')]
    else:
        text_box_names = []

    scanner = WebScanner()
    scanner.scan_url(url, payloads, method, text_box_names)
    scanner.report(output_format)

if __name__ == '__main__':
    cli()
